//
//  test.cpp
//  mirror tree
//
//  Created by John  on 13.03.16.
//
/*
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。


上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
示例 2:

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-sudoku
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <stack>
#include <cstring>
#include <limits.h>
#include <algorithm>

using namespace std;
class Solution {
public:
  bool isValidSudoku(vector<vector<char>>& board)
  {
    int col_appear[9][9] = {0};
    int row_appear[9][9] = {0};
    int box_appear[9][9] = {0}; 
    int box_index = 0;
    int box_tmp = 0;
    for (int i = 0;i < 9;i++)
    {
      if (i % 3 != 0)
      {
        box_index -= 3;
      }
      for (int j = 0;j < 9;j++)
      {
        std::cout<< "row index["<<i<<"] col index["<<j<<std::endl;
        if (board[i][j] == '.')
        {
          continue;
        }
        
        int value = board[i][j] - '1';
        if (row_appear[i][value] == 1)
        {
          std::cout<< "row appear row index["<<i<<"] col index["<<j<<std::endl;
          return false;
        }
        if (col_appear[j][value] == 1)
        {
          std::cout<< "col appear row index["<<i<<"] col index["<<j<<std::endl;
          return false;
        }

        //int box_index = (i / 3) * 3 + (j / 3);
        box_tmp = box_index + (j / 3);
        if (box_appear[box_tmp][value] == 1)
        {
          std::cout<< "box appear row index["<<i<<"] col index["<<j<<std::endl;
          return false;
        }

        row_appear[i][value] = 1;
        col_appear[j][value] = 1;
        box_appear[box_tmp][value] = 1;
        std::cout<< "box index["<<box_tmp<<"]"<<std::endl;
      }
      box_index += 3;
    }

    return true;
  }

};

int main()
{
  Solution solution;
  
  // {'5','3','.','.','7','.','.','.','.'},
  // {'6','.','.','1','9','5','.','.','.'},
  // {'.','9','8','.','.','.','.','6','.'},
  // {'8','.','.','.','6','.','.','.','3'},
  // {'4','.','.','8','.','3','.','.','1'},
  // {'7','.','.','.','2','.','.','.','6'},
  // {'.','6','.','.','.','.','2','8','.'},
  // {'.','.','.','4','1','9','.','.','5'},
  // {'.','.','.','.','8','.','.','7','9'}
  
  vector<vector<char>> board = {{'5','3','.','.','7','.','.','.','.'},{'6','.','.','1','9','5','.','.','.'},{'.','9','8','.','.','.','.','6','.'},{'8','.','.','.','6','.','.','.','3'},{'4','.','.','8','.','3','.','.','1'},{'7','.','.','.','2','.','.','.','6'},{'.','6','.','.','.','.','2','8','.'},{'.','.','.','4','1','9','.','.','5'},{'.','.','.','.','8','.','.','7','9'}};

  bool ret = solution.isValidSudoku(board);
  
  std::cout<<"ret:["<<ret<<"]"<<std::endl;

  return 0;
}